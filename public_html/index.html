<!DOCTYPE html>
<html lang="en">
    <head>
        <title>three.js webgl - geometry - cube</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    </head>
    <body>

        <script src="js/three.js"></script>
        <script src="js/Tween.js"></script>
        <script src="js/OrbitControls.js"></script>
        <script>
            var controls, rotspeed, scene, camera,
                    renderer, geom, stack, pai, marcacao,
                    arestas, faces, graph, vertices, verticeAtual,
                    distancia, ordemBFS, eixosRotacao, pontosBase, selected,
                    angle;
            var mouse = {x: 0, y: 0};
            var targetList = [];
            var geometries = [];


            function init() {

                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

                camera.position.set(-5, 1, 3);
                camera.lookAt(scene.position);

                rotSpeed = 0.001;
                controls = new THREE.OrbitControls(camera);
                controls.addEventListener('change', render);
                scene.add(camera);
                renderer = new THREE.WebGLRenderer();
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(renderer.domElement);

                switch (poliedro) {
                    case 'octaedro':
                        initOctaedro();
                        break;

                    case 'icosaedro':
                        initIcosaedro();
                        break;

                    case 'tetraedro':
                        initTetraedro();
                        break;
                }

                for (var i = 0; i < faces.length; i += 1) {
                    geom = new THREE.Geometry();
                    geom.vertices = vertices;
                    var face = faces[i];
                    var color = Math.random() * 0xffffff;
                    face.color.setHex(color);
                    geom.faces = [face];
                    geom.computeFaceNormals();
                    var material = new THREE.MeshBasicMaterial({vertexColors: THREE.FaceColors, side: THREE.DoubleSide});
                    var mesh = new THREE.Mesh(geom, material);
                    scene.add(mesh);
                    geometries.push(geom);
                    targetList.push(mesh);

                }

                document.addEventListener('mousedown', abrirPoliedro, false);
                window.addEventListener('resize', onWindowResize, false);

            }

            function initOctaedro() {
                angle = (180 - 109.47122) * 0.0174533;
                vertices = [
                    new THREE.Vector3(1, 0, 0), // 0 
                    new THREE.Vector3(0, 1, 0), // 1
                    new THREE.Vector3(0, 0, 1), // 2 
                    new THREE.Vector3(-1, 0, 0), // 3
                    new THREE.Vector3(0, -1, 0), // 4
                    new THREE.Vector3(0, 0, -1) // 5
                ];

                faces = [
                    new THREE.Face3(0, 1, 2), // 0
                    new THREE.Face3(3, 1, 5), // 1
                    new THREE.Face3(5, 1, 0), // 2
                    new THREE.Face3(2, 1, 3), // 3
                    new THREE.Face3(2, 4, 0), // 4
                    new THREE.Face3(5, 4, 3), // 5
                    new THREE.Face3(0, 4, 5), // 6
                    new THREE.Face3(3, 4, 2)  // 7

                ];
                resetVertices();

//                graph = [
//                    // 0 1 2 3 4 5 6 7 
//                    [0, 0, 1, 1, 1, 0, 0, 0],
//                    [0, 0, 1, 1, 0, 1, 0, 0],
//                    [1, 1, 0, 0, 0, 0, 1, 0],
//                    [1, 1, 0, 0, 0, 0, 0, 1],
//                    [1, 0, 0, 0, 0, 0, 1, 1],
//                    [0, 1, 0, 0, 0, 0, 1, 1],
//                    [0, 0, 1, 0, 1, 1, 0, 0],
//                    [0, 0, 0, 1, 1, 1, 0, 0]
//                ];


                graph = [
                    // 0 1 2 3 4 5 6 7 
                    [2, 3, 4],
                    [2, 3, 5],
                    [0, 1, 6],
                    [0, 1, 7],
                    [0, 6, 7],
                    [1, 6, 7],
                    [2, 4, 5],
                    [3, 4, 5]
                ];
            }

            function initIcosaedro() {
                angle = (180 - 138.19) * 0.0174533;
                var t = (1.0 + Math.sqrt(5.0)) / 2.0;
                vertices = [
                    new THREE.Vector3(-1, t, 0),
                    new THREE.Vector3(1, t, 0),
                    new THREE.Vector3(-1, -t, 0),
                    new THREE.Vector3(1, -t, 0),
                    new THREE.Vector3(0, -1, t),
                    new THREE.Vector3(0, 1, t),
                    new THREE.Vector3(0, -1, -t),
                    new THREE.Vector3(0, 1, -t),
                    new THREE.Vector3(t, 0, -1),
                    new THREE.Vector3(t, 0, 1),
                    new THREE.Vector3(-t, 0, -1),
                    new THREE.Vector3(-t, 0, 1)
                ];
                faces = [
                    new THREE.Face3(0, 11, 5), //0 
                    new THREE.Face3(0, 5, 1),
                    new THREE.Face3(0, 1, 7),
                    new THREE.Face3(0, 7, 10),
                    new THREE.Face3(0, 10, 11),
                    new THREE.Face3(1, 5, 9), //5
                    new THREE.Face3(5, 11, 4),
                    new THREE.Face3(11, 10, 2),
                    new THREE.Face3(10, 7, 6),
                    new THREE.Face3(7, 1, 8),
                    new THREE.Face3(3, 9, 4), //10
                    new THREE.Face3(3, 4, 2),
                    new THREE.Face3(3, 2, 6),
                    new THREE.Face3(3, 6, 8),
                    new THREE.Face3(3, 8, 9),
                    new THREE.Face3(4, 9, 5), //15
                    new THREE.Face3(2, 4, 11),
                    new THREE.Face3(6, 2, 10),
                    new THREE.Face3(8, 6, 7),
                    new THREE.Face3(9, 8, 1)
                ];
                resetVertices();

                graph = [
                    [1, 4, 6], [0, 2, 5], [1, 3, 9], [2, 4, 8],
                    [0, 3, 7], [1, 15, 19], [0, 15, 16], [4, 16, 17],
                    [3, 17, 18], [2, 18, 19], [11, 14, 15], [10, 12, 16],
                    [11, 13, 17], [12, 14, 18], [10, 13, 19], [5, 6, 10],
                    [6, 7, 11], [7, 8, 12], [8, 9, 13], [5, 9, 14]
                ];
            }

            function initTetraedro() {
                angle = (180 - 70.53) * 0.0174533;

                vertices = [
                    new THREE.Vector3(1, 1, 1),
                    new THREE.Vector3(-1, -1, 1),
                    new THREE.Vector3(-1, 1, -1),
                    new THREE.Vector3(1, -1, -1)
                ];
                faces = [
                    new THREE.Face3(2, 1, 0),
                    new THREE.Face3(0, 3, 2),
                    new THREE.Face3(1, 3, 0),
                    new THREE.Face3(2, 3, 1)
                ];

                resetVertices();

                graph = [
                    [1, 2, 3],
                    [0, 2, 3],
                    [0, 1, 3],
                    [0, 1, 2]
                ];
            }



            function abrirPoliedro(event)
            {
//                event.preventDefault();
                console.log("abrir poliedro..");



                // update the mouse variable
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                var ray = new THREE.Raycaster();
                ray.setFromCamera(mouse, camera);
                // create an array containing all objects in the scene with which the ray intersects
                var intersects = ray.intersectObjects(targetList);
                // if there is one (or more) intersections
                if (intersects.length > 0)
                {
                    BFSExplorer(faces.indexOf(intersects[ 0 ].face));
//                    console.log("Tabela de pai: " + pai);
                    BFSExecuter(faces.indexOf(intersects[ 0 ].face));
                    selected = intersects[ 0 ].face;
                }

//                console.log("done para " + filho);

            }

            function fecharPoliedro(event) {
//                event.preventDefault();


                console.log("fechar poliedro..");

                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                var ray = new THREE.Raycaster();
                ray.setFromCamera(mouse, camera);
                // create an array containing all objects in the scene with which the ray intersects
                var intersects = ray.intersectObjects(targetList);
                // if there is one (or more) intersections
                if (intersects.length > 0)
                {
                    if (selected === intersects[ 0 ].face) {
                        for (var i = ordemBFS.length - 1; i > 0; i -= 1) {
                            transformRecurs(eixosRotacao[ordemBFS[i]], -angle, ordemBFS[i], pontosBase[ordemBFS[i]]);
                        }
                        document.addEventListener('mousedown', abrirPoliedro, false);
                        document.removeEventListener("mousedown", fecharPoliedro);
                    }

                }

            }


            function animate()
            {
                requestAnimationFrame(animate);
                TWEEN.update();
                update();
                render();
            }

            function render() {

                var x = camera.position.x;
                var z = camera.position.z;
                camera.position.x = x * Math.cos(rotSpeed) + z * Math.sin(rotSpeed);
                camera.position.z = z * Math.cos(rotSpeed) - x * Math.sin(rotSpeed);
                camera.lookAt(scene.position);
                renderer.render(scene, camera);

            }
            function update()
            {
                controls.update();
            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            function BFSExplorer(indexF) {
                //pai[0]=face;
                //marca indexF
                //para cada vizinho de indexF 
                //  unshift no stack
                //  pai do vizinho = face
                //ENQUANTO STACK não estiver vazio do:
                //  POP STACK faceTEMP;]
                //  MARCA FACETEMP
                //  para cada vizinho de faceTEMP que não esta marcados
                //      unshift no stack
                //      pai[vizinhoFACE] = faceTEMP;
                //transformar faceTEMP em relação ao PAI
                stack = new Array();
                pai = [];
                marcacao = [];
                distancia = [];
                ordemBFS = new Array();
                eixosRotacao = [];
                pontosBase = [];

                pai[indexF] = indexF;
                distancia[indexF] = 0;
                ordemBFS.push(indexF);
                console.log(indexF);
                marcacao[indexF] = true;

                //pegar os vizinhos
                for (var i = 0; i < graph[indexF].length; i += 1) {
                    if (!marcacao[graph[indexF][i]]) {
                        stack.unshift(graph[indexF][i]);
                        pai[graph[indexF][i]] = indexF;
                        marcacao[graph[indexF][i]] = true;
                        distancia[graph[indexF][i]] = 1;
                    }
                }

                //ENQUANTO STACK não estiver vazio do:
                while (stack.length > 0) {
                    var faceTemp = stack.pop();
                    ordemBFS.push(faceTemp);
                    for (var i = 0; i < graph[faceTemp].length; i += 1) {
                        if (!marcacao[graph[faceTemp][i]]) {
                            stack.unshift(graph[faceTemp][i]);
                            pai[graph[faceTemp][i]] = faceTemp;
                            marcacao[graph[faceTemp][i]] = true;
                            distancia[graph[faceTemp][i]] = distancia[faceTemp] + 1;
                        }
                    }


                }
                console.log(ordemBFS);
                console.log(pai);

            }

            var test = false;
            function BFSExecuter(indexF) {


                stack = new Array();
                marcacao = [];
                marcacao[indexF] = true;
                //pegar os vizinhos
                for (var i = 0; i < graph[indexF].length; i += 1) {

                    if (!marcacao[graph[indexF][i]]) {
                        stack.unshift(graph[indexF][i]);
                        marcacao[graph[indexF][i]] = true;
                    }
                }
                var count = 0;
                //ENQUANTO STACK não estiver vazio do:
                while (stack.length > 0) {
                    var faceTemp = stack.pop();
                    for (var i = 0; i < graph[faceTemp].length; i += 1) {
                        if (!marcacao[graph[faceTemp][i]]) {
                            stack.unshift(graph[faceTemp][i]);
                            marcacao[graph[faceTemp][i]] = true;
                        }
                    }
                    count += 1;

                    transformFace(faceTemp, pai[faceTemp]);


                }


                document.removeEventListener("mousedown", abrirPoliedro);
                document.addEventListener('mousedown', fecharPoliedro, false);
            }


            function transformFace(filho, paiF) {

                //ver qual o eixo em comum entre indexF e indexP
                var F = geometries[filho].faces[0];
                var P = geometries[paiF].faces[0];


                var verticesFace = [F.a, F.b, F.c];
                var verticesPai = [P.a, P.b, P.c];

                //pegar vertices em comum na ordem certa(sentido horário da face pai)
                //complexidade de n², porem n é muito pequeno(3), então tá ok!
                var intersec = [];
                var jTemp = null;
                for (var i = 0; i < verticesFace.length; i += 1) {
                    for (var j = 0; j < verticesPai.length; j += 1) {
                        if (verticesFace[i] === verticesPai[j]) {
                            if (jTemp === null) {
                                jTemp = j;
                                intersec.unshift(verticesFace[i]);
                            } else if (j < jTemp) {
                                if (jTemp === (verticesPai.length - 1) && j === 0) {
                                    intersec.unshift(verticesFace[i]);
                                } else {
                                    intersec.push(verticesFace[i]);
                                }

                            } else {
                                if (jTemp === 0 && j === (verticesPai.length - 1)) {
                                    intersec.push(verticesFace[i]);
                                } else {
                                    intersec.unshift(verticesFace[i]);
                                }

                            }
                        }
                    }
                }


                var ponto0 = intersec[0];
                var ponto1 = intersec[1];
                var a = new THREE.Vector3();
                var b = new THREE.Vector3();

                a.copy(verticeAtual[paiF][ponto1]);
                b.copy(verticeAtual[paiF][ponto0]);


                if (filho === 1 && paiF === 0) {
                    console.log(intersec);
                }



                var axisRotation = a.sub(b);
                eixosRotacao[filho] = axisRotation;
                pontosBase[filho] = ponto0;



                transformRecurs(axisRotation, angle, filho, ponto0, 1);

            }

            function transformRecurs(axisRotation, angleFace, indexF, ponto0) {


                targetList[indexF].rotateAroundWorldAxis(verticeAtual[pai[indexF]][ponto0], axisRotation.normalize(), angleFace);
                targetList[indexF].updateMatrixWorld();

                //Atualizar Vertices 
                for (var i = 0; i < vertices.length; i += 1) {
                    var vector = new THREE.Vector3();
                    vector.copy(targetList[indexF].geometry.vertices[ i ]);
                    vector.applyMatrix4(targetList[indexF].matrixWorld);

                    verticeAtual[indexF][i] = vector;
                }



                //fazer para todos os filhos
                for (var i = 0; i < pai.length; i += 1) {
                    if (pai[i] === indexF && i !== indexF) {
//                        console.log(i + " , " + pai[i]);
                        transformRecurs(axisRotation, angleFace, i, ponto0);
//                        console.log("Transformação aplicada para " + faces.indexOf(geometries[i].faces[0]) + " // Filho de " + indexF);
                    }

                }
            }


            function fechaRecurs(axisRotation, angleFace, indexF, ponto0) {
                targetList[indexF].rotateAroundWorldAxis(verticeAtual[pai[indexF]][ponto0], axisRotation.normalize(), angleFace);
                targetList[indexF].updateMatrixWorld();

            }

            THREE.Object3D.prototype.rotateAroundWorldAxis = function () {

                var q1 = new THREE.Quaternion();
                return function (point, axis, angle) {
                    q1.setFromAxisAngle(axis, angle);

                    this.quaternion.multiplyQuaternions(q1, this.quaternion);

                    this.position.sub(point);
                    this.position.applyQuaternion(q1);
                    this.position.add(point);



                    return this;
                };

            }();

            function resetVertices() {
                verticeAtual = [];
                for (var i = 0; i < faces.length; i += 1) {
                    verticeAtual[i] = [];
                    for (var j = 0; j < vertices.length; j += 1) {
                        verticeAtual[i][j] = new THREE.Vector3();
                        verticeAtual[i][j].copy(vertices[j]);
                    }
                }
            }


            function mudarPoliedro(p) {
                poliedro = p;
                start();
            }


            function start() {
                document.getElementById('escolha').style.display = 'none';
                init();
                animate();

            }


        </script>


        <div id="escolha">
            <center>
                <b>Caio César Riqueza Ramos </b>
                <br><br><br><br>
                Funcionalidades:
                    <ul>
                        <li>Suporta 3 poliedros: Icosaedro, Octaedro e Tetraedro;</li>
                        <li>Abertura e fechamento do poliedro;</li>
                        <li>Possibilita giro do poliedro de forma a examiná-lo de todos os ângulos;</li>
                        <li>Escolher qual face de abertura;</li>


                    </ul>
                <br><br><br><br>
                Escolha um poliedro:
                <br>
                <button onClick="mudarPoliedro('icosaedro')">Icosaedro</button>
                <button onClick="mudarPoliedro('tetraedro')">Tetraedro</button>
                <button onClick="mudarPoliedro('octaedro')">Octaedro</button>           




            </center>
        </div>
    </body>
</html>